# Huffman 编码压缩

## 1 算法原理

Huffman于1952年提出一种编码方法，该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码，一般就叫做Huffman编码。

## 2 算法流程

压缩流程如下：

```flow
st=>start: 开始
in=>inputoutput: 输入待压缩文件和压缩文件的路径
op1=>operation: 统计文件中各字节出现的频率，根据频率构造 Huffman 树
op2=>operation: 根据 Huffman 树对字节进行编码
op3=>operation: 将该树（包括编码）写入压缩文件
op4=>operation: 读取文件，写入各字节对应的编码
e=>end: 结束
st->in->op1->op2->op3->op4->e
```

解压流程如下：

```flow
st=>start: 开始
in=>inputoutput: 输入压缩文件和解压文件的路径
op1=>operation: 从文件头读取 Huffman 树
op2=>operation: 读取剩余文件，根据 Huffman 树进行解码，
将 Huffman 编码对应的原字节写入解压文件
e=>end: 结束
st->in->op1->op2->e
```

## 3 细节实现

### 3.1 类

`Node`类表示节点，属性包括节点表示的字节`character`，对应的 Huffman 编码`code`，权值`weight`，以及子节点`leftChild`和`rightChild`。`Node`类实现了`Serializable`接口，可以将节点序列化。

`Tree`类表示树，属性包括树的根节点`root`，叶节点权值之和`weight`。`Tree`类实现了`Comparable`接口，重写了`compareTo`方法，从而可以根据树的权值进行排序。

`HuffmanTree`类表示 Huffman 树，继承自`Tree`类，属性包括`Tree`的属性，还有各字节和对应的编码`codes`。

`Compress`类包括压缩和解压操作。

### 3.2 构造 Huffman 树

Huffman 树构造方法如下：

> 假设有n个权值，则构造出的哈夫曼树有 n 个叶子节点。 n 个权值分别设为  w~1~、w~2~、…、w~n~，则 Huffman 树的构造规则为：
>
> (1)  将 w~1~、w~2~、…、w~n~ 看成是有 n 棵树的树林（每棵树仅有一个节点）；
>
> (2)  在树林中选出两个根节点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根节点权值为其左、右子树根节点权值之和；
>
> (3) 从树林中删除选取的两棵树，并将新树加入树林；
>
> (4) 重复(2)、(3)步，直到树林中只剩一棵树为止，该树即为所求得的 Huffman 树。

首先用各字节及其频率构造多棵树（`Tree`），加入树林（`ArrayList<Tree>`）。首先使用`sort`方法根据频率进行一次排序，然后每次取出最小的两棵树，合并为一棵树，将两棵树权值之和作为新的权值，将新树按顺序加入树林的适当位置，直到树林中只有一棵树，该树即为 Huffman 树。由于`Tree`类实现了`Comparable`接口，所以可以直接进行排序。此处只进行一次排序，可以减少代码量和构造时的操作次数。

### 3.3 生成 Huffman 编码

Huffman 树的每个叶节点都表示不同的字节，根据其路径进行编码，从根节点开始，每经过左子树或右子树，分别在编码后加上 0 或 1。使用递归方法，从根节点开始，为子节点分配编码，代码如下：

```java
private void generateCode(Node root, String code) {
    // 如果该节点不是叶节点
    if (root.getLeftChild() != null && root.getRightChild() != null) {
        // 分别以code||0和code||1为前缀生成子节点的编码
        generateCode(root.getLeftChild(), code + "0");
        generateCode(root.getRightChild(), code + "1");
    } else {
        // 如果该节点为叶节点，则编码就是code
        root.setCode(code);
    }
}
```

### 3.4 不定长度编码写入

由于 Huffman 编码不是等长的，而文件是由字节组成的，所以需要设置缓冲区，缓冲区内的 Huffman 编码满 8 位后写入文件。

### 3.5 文件末尾处理

经过压缩后的编码可能不是整字节的，所以需要填充，这里使用 0 填充。同时为了标记填充的位数，在文件最后追加了一字节，记录填充的位数。较于其他方法，如在文件头记录所有的字节数，该方法仅使用一字节，可以节省一部分空间。

### 3.6 解压译码

解压时不易区分不同的编码，这里选择重构 Huffman 树。从第一位开始，从树的根节点向下查找，0 和 1 分别代表左子树和右子树，当找到叶节点时即读完一个 Huffman 编码，重复进行即可完成解压。由于 Huffman 编码的不同长度，一字节可能包括多个编码或无法表示一个完整编码，所以也需要设置缓冲区，这里设置了64位的缓冲区，当缓冲区达到32位时持续解压。

由于文件末尾有填充和标记，所以解压时需要对这一部分进行处理。这里使用读取完一字节后处理上一字节的方法，读到末尾时进行特殊处理。读取最后8位（即填充的位数），去掉这8位和填充位，解压至缓冲区清空。

### 3.7 其他说明

实验环境为JDK 15.0.1，仅实现非空文件的二元 Huffman 编码解压和压缩，未实现空文件的压缩和解压以及多元 Huffman 编码压缩和解压。

包含文件如下：

![1](source\1.png)

可以在`\out\production\Huffman`路径下使用`java Compress [compress/decompress] [输入文件] [输出文件]`命令对文件进行压缩或者解压。

## 4  压缩结果与分析

这里选择了全英文的哈利波特第一部txt文件，蓝白色北航校徽png和bmp图片作为压缩程序的输入，将压缩的文件再进行解压，结果如下：

| 原文件名 | 文件内容      | 原文件大小               | 压缩文件大小          | 解压文件大小             | 压缩率  |
| -------- | ------------- | ------------------------ | --------------------- | ------------------------ | ------- |
| test.txt | 全英文文本    | 441 KB (451,867 字节)    | 259 KB (266,116 字节) | 441 KB (451,867 字节)    | 58.89%  |
| test.png | 蓝白色png图片 | 344 KB (352,714 字节)    | 351 KB (359,973 字节) | 344 KB (352,714 字节)    | 102.06% |
| test.bmp | 蓝白色bmp图片 | 1.02 MB (1,080,054 字节) | 473 KB (484,425 字节) | 1.02 MB (1,080,054 字节) | 44.85%  |

可见，txt和bmp文件的压缩效率是比较高的，而png文件的压缩效率极低，甚至出现了压缩文件比原文件大的现象。

Huffman 编码压缩就是将原文件的各字节根据频率进行重新编码，频率越高的字节对应的编码越短，极端情况下编码长度与字节长度相等，因此可以压缩，且字节种类越少，频率差异越大，压缩效率越高。

各文件字节种类及频次方差如下：

| 文件     | 字节种类数量 | 频次方差   | 压缩率  |
| -------- | ------------ | ---------- | ------- |
| test.txt | 81           | 124776737  | 58.89%  |
| test.png | 256          | 7892       | 102.06% |
| test.bmp | 256          | 1641138850 | 44.85%  |

经过分析，txt文件保存的字符种类有限，且频率相差较大，Huffman 编码对于高频字符使用较短编码，与使用8位的原编码相比可以节省很多空间。bmp文件类似，不经过任何处理地保存像素域的数据，因此当图像色彩数量较少时也可得到较短的 Huffman 编码，可有效压缩。而png本身就是压缩后的图片，经过分析编码，各种字节均有出现且频率类似，因此压缩效率极低，再加上文件头，导致压缩文件可能大于原文件。

## 5 多元 Huffman 编码压缩

多元 Huffman 编码压缩的难点在于需要多位来储存单个字母，而且编码时需要对码字进行补充，以满足$q≡1\mod(r-1)$。

对于压缩效率，由于3元和5元 Huffman 编码在计算机存储中需要多位，所以会造成冗余，大多数情况下压缩效率低于2元 Huffman 编码压缩。

